# coding: utf-8

"""
    PRO SHIPPING API

    # Introduction Here you will find requirements for integrating with PRO SHIPPING API.  The documentation specifically covers how the API can be used by business customers to conduct shipping activity with available carriers and provides the technical information to build this integration. The API allows customers to create and manage shipments, produce labels, customs documentation, and collection manifests, retrieve reference data such as carriers and countries, and maintain their own data such as shipping account details.  Pro Shipping API is a fully RESTful service implemented using JSON messaging. You, as the customer are responsible for sending JSON messages and for maintaining the capability of receiving JSON messages in the format described in this specification. Request and response examples for each API service are included in this specification.  # Authentication  The PRO SHIPPING API uses OAuth2 authentication.  To request the authorization token you need to create API credentials (Client ID and Secret) on the system first. If you have not done it already, log into your account and go to API Credentials or follow the link [add a link here with the path to the API Credentials menu]. Use the credentials to retrieve the authorization token.  Note: Make sure you copy the Secret and keep it secure as you won't be able to view it again on the system.  <!-- ReDoc-Inject: <SecurityDefinitions /> -->   # noqa: E501

    OpenAPI spec version: v4.0-RM
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from rmail_apiv4.api_client import ApiClient


class ShipmentsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def v4_shipments_defer_put(self, **kwargs):  # noqa: E501
        """Defer Shipments  # noqa: E501

        Used to update the shipment shipping data for a current shipment. <br />A shipment can be deferred by a maximum of 28 days from the date of the request. <br />This service can only be used before the shipment has been manifested. <br />There can be a maximum of 99 defer requests per call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_defer_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[DeferShipmentRequest] body: Defer shipment requests
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v4_shipments_defer_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v4_shipments_defer_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v4_shipments_defer_put_with_http_info(self, **kwargs):  # noqa: E501
        """Defer Shipments  # noqa: E501

        Used to update the shipment shipping data for a current shipment. <br />A shipment can be deferred by a maximum of 28 days from the date of the request. <br />This service can only be used before the shipment has been manifested. <br />There can be a maximum of 99 defer requests per call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_defer_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[DeferShipmentRequest] body: Defer shipment requests
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v4_shipments_defer_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/v4/shipments/defer', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v4_shipments_preallocate_tracking_number_rm_post(self, **kwargs):  # noqa: E501
        """Pre Allocate Tracking Number  # noqa: E501

        This service can be used to receive a Royal Mail Tracking Number that will be pre-allocated to the service and destination supplied in the request. No shipment or label will be produced from this service. <br />This service can only be used for services that are assigned a tracking number. <br />This service must be used in conjunction with CreateShipment service populating the TrackingNumber in the CarrierSpecifics /PreAllocatedBarcode section with the pre-allocated TrackingNumber returned in this service response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_preallocate_tracking_number_rm_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PreAllocateTrackingNumberRequest body: The request.
        :return: PreAllocateTrackingNumberResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v4_shipments_preallocate_tracking_number_rm_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v4_shipments_preallocate_tracking_number_rm_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v4_shipments_preallocate_tracking_number_rm_post_with_http_info(self, **kwargs):  # noqa: E501
        """Pre Allocate Tracking Number  # noqa: E501

        This service can be used to receive a Royal Mail Tracking Number that will be pre-allocated to the service and destination supplied in the request. No shipment or label will be produced from this service. <br />This service can only be used for services that are assigned a tracking number. <br />This service must be used in conjunction with CreateShipment service populating the TrackingNumber in the CarrierSpecifics /PreAllocatedBarcode section with the pre-allocated TrackingNumber returned in this service response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_preallocate_tracking_number_rm_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PreAllocateTrackingNumberRequest body: The request.
        :return: PreAllocateTrackingNumberResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v4_shipments_preallocate_tracking_number_rm_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/v4/shipments/preallocateTrackingNumber/rm', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PreAllocateTrackingNumberResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v4_shipments_print_document_carrier_code_shipment_id_post(self, carrier_code, shipment_id, **kwargs):  # noqa: E501
        """Print Document  # noqa: E501

        Request the associated Customs Documents for the printed label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_print_document_carrier_code_shipment_id_post(carrier_code, shipment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str carrier_code: Carrier Code (required)
        :param str shipment_id: Shipment Id <br />The Shipment Id may be an id or a tracking/barcode number. (required)
        :param PrintDocumentRequest body: Print Document Request
        :return: PrintDocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v4_shipments_print_document_carrier_code_shipment_id_post_with_http_info(carrier_code, shipment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.v4_shipments_print_document_carrier_code_shipment_id_post_with_http_info(carrier_code, shipment_id, **kwargs)  # noqa: E501
            return data

    def v4_shipments_print_document_carrier_code_shipment_id_post_with_http_info(self, carrier_code, shipment_id, **kwargs):  # noqa: E501
        """Print Document  # noqa: E501

        Request the associated Customs Documents for the printed label.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_print_document_carrier_code_shipment_id_post_with_http_info(carrier_code, shipment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str carrier_code: Carrier Code (required)
        :param str shipment_id: Shipment Id <br />The Shipment Id may be an id or a tracking/barcode number. (required)
        :param PrintDocumentRequest body: Print Document Request
        :return: PrintDocumentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['carrier_code', 'shipment_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v4_shipments_print_document_carrier_code_shipment_id_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'carrier_code' is set
        if ('carrier_code' not in params or
                params['carrier_code'] is None):
            raise ValueError("Missing the required parameter `carrier_code` when calling `v4_shipments_print_document_carrier_code_shipment_id_post`")  # noqa: E501
        # verify the required parameter 'shipment_id' is set
        if ('shipment_id' not in params or
                params['shipment_id'] is None):
            raise ValueError("Missing the required parameter `shipment_id` when calling `v4_shipments_print_document_carrier_code_shipment_id_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'carrier_code' in params:
            path_params['carrierCode'] = params['carrier_code']  # noqa: E501
        if 'shipment_id' in params:
            path_params['shipmentId'] = params['shipment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/v4/shipments/printDocument/{carrierCode}/{shipmentId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PrintDocumentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v4_shipments_print_label_rm_shipment_id_get(self, shipment_id, **kwargs):  # noqa: E501
        """Print Label  # noqa: E501

        This changes the status of the shipment to label printed. This should be done at the time of actual printing or label creation dependent on how you operate in reality. Shipments must be updated to printed status prior to manifesting.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_print_label_rm_shipment_id_get(shipment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str shipment_id: Shipment Id <br />The Shipment Id may be an id or a tracking/barcode number. (required)
        :param RoyalMailLabelFormat label_format: Label Format <br />             <br />**PDF** Base 64 encoded PDF <br />**PNG** Base 64 encoded PNG <br />**DATASTREAM** - Label components broken down into a data-stream, for you to draw your own label <br />**ZPL203DPI** Base 64 encoded text for Zebra printer at 203 DPI <br />**ZPL300DPI** Base 64 encoded text for Zebra printer at 300 DPI <br />             <br />*DATASTREAM is only available if it has been activated on your account.* <br />             <br />Defaults To PDF
        :return: RoyalMailLabelFormatRoyalMailShipmentResponseCarrierSpecificsPrintLabelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v4_shipments_print_label_rm_shipment_id_get_with_http_info(shipment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.v4_shipments_print_label_rm_shipment_id_get_with_http_info(shipment_id, **kwargs)  # noqa: E501
            return data

    def v4_shipments_print_label_rm_shipment_id_get_with_http_info(self, shipment_id, **kwargs):  # noqa: E501
        """Print Label  # noqa: E501

        This changes the status of the shipment to label printed. This should be done at the time of actual printing or label creation dependent on how you operate in reality. Shipments must be updated to printed status prior to manifesting.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_print_label_rm_shipment_id_get_with_http_info(shipment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str shipment_id: Shipment Id <br />The Shipment Id may be an id or a tracking/barcode number. (required)
        :param RoyalMailLabelFormat label_format: Label Format <br />             <br />**PDF** Base 64 encoded PDF <br />**PNG** Base 64 encoded PNG <br />**DATASTREAM** - Label components broken down into a data-stream, for you to draw your own label <br />**ZPL203DPI** Base 64 encoded text for Zebra printer at 203 DPI <br />**ZPL300DPI** Base 64 encoded text for Zebra printer at 300 DPI <br />             <br />*DATASTREAM is only available if it has been activated on your account.* <br />             <br />Defaults To PDF
        :return: RoyalMailLabelFormatRoyalMailShipmentResponseCarrierSpecificsPrintLabelResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shipment_id', 'label_format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v4_shipments_print_label_rm_shipment_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'shipment_id' is set
        if ('shipment_id' not in params or
                params['shipment_id'] is None):
            raise ValueError("Missing the required parameter `shipment_id` when calling `v4_shipments_print_label_rm_shipment_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'shipment_id' in params:
            path_params['shipmentId'] = params['shipment_id']  # noqa: E501

        query_params = []
        if 'label_format' in params:
            query_params.append(('labelFormat', params['label_format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/v4/shipments/printLabel/rm/{shipmentId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RoyalMailLabelFormatRoyalMailShipmentResponseCarrierSpecificsPrintLabelResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v4_shipments_print_my_label_qr_code_rm_shipment_id_get(self, shipment_id, **kwargs):  # noqa: E501
        """Print My Label QR Code  # noqa: E501

        Request associated QR Code for the associated label in the print label call. <br />This is only available for Royal Mail Tracked Return Services.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_print_my_label_qr_code_rm_shipment_id_get(shipment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str shipment_id: Shipment Id <br />The Shipment Id may be an id or a tracking/barcode number. (required)
        :return: QRCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v4_shipments_print_my_label_qr_code_rm_shipment_id_get_with_http_info(shipment_id, **kwargs)  # noqa: E501
        else:
            (data) = self.v4_shipments_print_my_label_qr_code_rm_shipment_id_get_with_http_info(shipment_id, **kwargs)  # noqa: E501
            return data

    def v4_shipments_print_my_label_qr_code_rm_shipment_id_get_with_http_info(self, shipment_id, **kwargs):  # noqa: E501
        """Print My Label QR Code  # noqa: E501

        Request associated QR Code for the associated label in the print label call. <br />This is only available for Royal Mail Tracked Return Services.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_print_my_label_qr_code_rm_shipment_id_get_with_http_info(shipment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str shipment_id: Shipment Id <br />The Shipment Id may be an id or a tracking/barcode number. (required)
        :return: QRCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shipment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v4_shipments_print_my_label_qr_code_rm_shipment_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'shipment_id' is set
        if ('shipment_id' not in params or
                params['shipment_id'] is None):
            raise ValueError("Missing the required parameter `shipment_id` when calling `v4_shipments_print_my_label_qr_code_rm_shipment_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'shipment_id' in params:
            path_params['shipmentId'] = params['shipment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/v4/shipments/printMyLabelQRCode/rm/{shipmentId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QRCodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v4_shipments_rm_post(self, **kwargs):  # noqa: E501
        """Create Shipment  # noqa: E501

        Create a Royal Mail shipment. This will return an image of the shipping label in PDF, PNG or ZPL format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_rm_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RoyalMailShipmentRequestCarrierSpecificsRoyalMailPackageRoyalMailLabelFormatCreateShipmentRequest body: Shipment Details
        :return: RoyalMailLabelFormatRoyalMailShipmentResponseCarrierSpecificsPackageResponseCreateShipmentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v4_shipments_rm_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v4_shipments_rm_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def v4_shipments_rm_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create Shipment  # noqa: E501

        Create a Royal Mail shipment. This will return an image of the shipping label in PDF, PNG or ZPL format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_rm_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RoyalMailShipmentRequestCarrierSpecificsRoyalMailPackageRoyalMailLabelFormatCreateShipmentRequest body: Shipment Details
        :return: RoyalMailLabelFormatRoyalMailShipmentResponseCarrierSpecificsPackageResponseCreateShipmentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v4_shipments_rm_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/v4/shipments/rm', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RoyalMailLabelFormatRoyalMailShipmentResponseCarrierSpecificsPackageResponseCreateShipmentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v4_shipments_shipping_location_id_get(self, shipping_location_id, **kwargs):  # noqa: E501
        """Get Shipments  # noqa: E501

        Provides a list of shipments for the specified shipping location in a given time period.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_shipping_location_id_get(shipping_location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str shipping_location_id: Shipping Location Id <br />PRO SHIPPING Shipping Location Id (assigned by PRO SHIPPING) or Alias (assigned by you). <br />Filter by shipping location. (required)
        :param str shipping_account_id: Shipping Account Id <br />PRO SHIPPING Shipping Account Id (assigned by PRO SHIPPING) or Alias (assigned by you). <br />Filter by shipping account.
        :param str carrier_code: Carrier Code <br />If shippingAccountId and carrier are both provided, then the value sent in the carrier field will be ignored and the carrier associated with the shipping account will be used.
        :param GetShipmentsStatusType status: Status <br />Filter by shipment status.
        :param str destination_country_code: Country Code <br />ISO Alpha-2 Country Code per ISO 3166 Standard.
        :param date date_from: Date From <br />Defaults to Today's date if not provided. <br />Format: YYYY-MM-DD
        :param date date_to: Date To <br />Defaults to Today's date if not provided. <br />Format: YYYY-MM-DD
        :param int page_size: The maximum number of records per page.
        :param int page_number: The number of the requested page, starting at 1.
        :return: ShipmentsPagedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v4_shipments_shipping_location_id_get_with_http_info(shipping_location_id, **kwargs)  # noqa: E501
        else:
            (data) = self.v4_shipments_shipping_location_id_get_with_http_info(shipping_location_id, **kwargs)  # noqa: E501
            return data

    def v4_shipments_shipping_location_id_get_with_http_info(self, shipping_location_id, **kwargs):  # noqa: E501
        """Get Shipments  # noqa: E501

        Provides a list of shipments for the specified shipping location in a given time period.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_shipping_location_id_get_with_http_info(shipping_location_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str shipping_location_id: Shipping Location Id <br />PRO SHIPPING Shipping Location Id (assigned by PRO SHIPPING) or Alias (assigned by you). <br />Filter by shipping location. (required)
        :param str shipping_account_id: Shipping Account Id <br />PRO SHIPPING Shipping Account Id (assigned by PRO SHIPPING) or Alias (assigned by you). <br />Filter by shipping account.
        :param str carrier_code: Carrier Code <br />If shippingAccountId and carrier are both provided, then the value sent in the carrier field will be ignored and the carrier associated with the shipping account will be used.
        :param GetShipmentsStatusType status: Status <br />Filter by shipment status.
        :param str destination_country_code: Country Code <br />ISO Alpha-2 Country Code per ISO 3166 Standard.
        :param date date_from: Date From <br />Defaults to Today's date if not provided. <br />Format: YYYY-MM-DD
        :param date date_to: Date To <br />Defaults to Today's date if not provided. <br />Format: YYYY-MM-DD
        :param int page_size: The maximum number of records per page.
        :param int page_number: The number of the requested page, starting at 1.
        :return: ShipmentsPagedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['shipping_location_id', 'shipping_account_id', 'carrier_code', 'status', 'destination_country_code', 'date_from', 'date_to', 'page_size', 'page_number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v4_shipments_shipping_location_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'shipping_location_id' is set
        if ('shipping_location_id' not in params or
                params['shipping_location_id'] is None):
            raise ValueError("Missing the required parameter `shipping_location_id` when calling `v4_shipments_shipping_location_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'shipping_location_id' in params:
            path_params['shippingLocationId'] = params['shipping_location_id']  # noqa: E501

        query_params = []
        if 'shipping_account_id' in params:
            query_params.append(('shippingAccountId', params['shipping_account_id']))  # noqa: E501
        if 'carrier_code' in params:
            query_params.append(('carrierCode', params['carrier_code']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'destination_country_code' in params:
            query_params.append(('destinationCountryCode', params['destination_country_code']))  # noqa: E501
        if 'date_from' in params:
            query_params.append(('dateFrom', params['date_from']))  # noqa: E501
        if 'date_to' in params:
            query_params.append(('dateTo', params['date_to']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'page_number' in params:
            query_params.append(('pageNumber', params['page_number']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/v4/shipments/{shippingLocationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ShipmentsPagedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def v4_shipments_status_put(self, **kwargs):  # noqa: E501
        """Update Status  # noqa: E501

        **Hold** - Put the shipments on hold for up to 28 days. Shipments on hold for longer than 28 days will be cancelled. A shipment on hold will not be included in an closeouts/manifests, but instead will remain in its current state. You can only put shipments on hold that are in the 'LabelPrinted' status as only shipments with this status are included in manifests. <br />             <br />**Cancel** - Use to cancel/void one or more current shipments. This can only be used before a shipment has been confirmed by being manifested. <br />             <br />**Release** - Use to release shipments from hold and shipments cancelled for less than 24 hours. Once released, the shipment will be included in the next manifest. <br />             <br />**Picked** - Set the shipment to picked. This means this shipment will only be manifested if you choose to manifest 'Picked' shipments.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_status_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateStatusRequest body: Update Status Request
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.v4_shipments_status_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.v4_shipments_status_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def v4_shipments_status_put_with_http_info(self, **kwargs):  # noqa: E501
        """Update Status  # noqa: E501

        **Hold** - Put the shipments on hold for up to 28 days. Shipments on hold for longer than 28 days will be cancelled. A shipment on hold will not be included in an closeouts/manifests, but instead will remain in its current state. You can only put shipments on hold that are in the 'LabelPrinted' status as only shipments with this status are included in manifests. <br />             <br />**Cancel** - Use to cancel/void one or more current shipments. This can only be used before a shipment has been confirmed by being manifested. <br />             <br />**Release** - Use to release shipments from hold and shipments cancelled for less than 24 hours. Once released, the shipment will be included in the next manifest. <br />             <br />**Picked** - Set the shipment to picked. This means this shipment will only be manifested if you choose to manifest 'Picked' shipments.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.v4_shipments_status_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateStatusRequest body: Update Status Request
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v4_shipments_status_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/v4/shipments/status', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
